<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2021/08/20/index/"/>
      <url>/2021/08/20/index/</url>
      
        <content type="html"><![CDATA[<h2 id="我的第二篇博客"><a href="#我的第二篇博客" class="headerlink" title="我的第二篇博客"></a>我的第二篇博客</h2><p>内容</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html 面试题</title>
      <link href="/2021/08/20/html-mian-shi-ti/"/>
      <url>/2021/08/20/html-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="html-面试题"><a href="#html-面试题" class="headerlink" title="html 面试题"></a>html 面试题</h1><h2 id="1-标签语义化作用"><a href="#1-标签语义化作用" class="headerlink" title="1.标签语义化作用"></a>1.标签语义化作用</h2><ol><li>见标签知其意，让代码结构更清晰方便阅读</li><li>有利于其他设备的解析，遵循 W3 规范以语义化标签渲染网页更利于搜索引擎的优化（SEO）</li></ol><h2 id="2-使用-dom-获取-input-中的值"><a href="#2-使用-dom-获取-input-中的值" class="headerlink" title="2.使用 dom 获取 input 中的值"></a>2.使用 dom 获取 input 中的值</h2><pre><code> const data= document.getElementById(&#39;input&#39;).value</code></pre><h2 id="3-5Cookie、session-和-LocalStorage-与-SessionStorage-的区别在哪里？"><a href="#3-5Cookie、session-和-LocalStorage-与-SessionStorage-的区别在哪里？" class="headerlink" title="3.5Cookie、session 和 LocalStorage 与 SessionStorage 的区别在哪里？"></a>3.5Cookie、session 和 LocalStorage 与 SessionStorage 的区别在哪里？</h2><ul><li>Cookie: cookie 就是客户端保存用户信息的一种机制，它的主要用途有保存登录信息</li></ul><ul><li>Session: Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。</li><li>LocalStoraged：localStorage 是一个保存于客户端的哈希表，可以用来保存本地的一些数据。并且不会因为刷新而释放，所以，可以使用 localStorage 来实现变量的持久化存储</li><li>SessionStorage: sessionStorage 的所有性质基本上与 localStorage 一致，唯一的不同区别在于：<br>sessionStorage 的有效期是页面会话持续，如果页面会话（session）结束（关闭窗口或标签页），sessionStorage 就会消失。而 localStorage 则会一直存在。</li></ul><h2 id="4-什么是-ajax-和-json"><a href="#4-什么是-ajax-和-json" class="headerlink" title="4 什么是 ajax 和 json"></a>4 什么是 ajax 和 json</h2><ol><li>ajax：</li></ol><ul><li>ajax 是一种通过后台与服务器进行少量的数据交换，使页面实现异步更新,是一种创建交互式网页应用的网页开发技术</li><li>优点:<ul><li>异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；</li></ul></li><li>缺点:<ul><li>异步回调问题、this 指向问题、路由跳转 back 问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</li></ul></li></ul><ol start="2"><li>json: json 是一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性</li></ol><ul><li>优点:<ul><li>数据格式比较简单，易于读写，格式都是压缩的，占用宽带小</li><li>支持多种语言，.JSON 格式的编码比较简单</li><li>JSON 的解码难度较低比起 XML 简单的多</li><li>JSON 和 js 交互更加方便</li><li>JSON 的速度远远快于 XML</li></ul></li><li>缺点:<ul><li>没有 XML 格式这么推广的深入人心和使用广泛, 没有 XML 那么通用性</li><li>JSON 格式目前在 Web Service 中推广还属于初级阶段 PS: 据说 Google 的 Ajax 是使用 JSON+模板 做的</li></ul></li></ul><h2 id="5-请说出三种减少页面加载时间的方法。"><a href="#5-请说出三种减少页面加载时间的方法。" class="headerlink" title="5. 请说出三种减少页面加载时间的方法。"></a>5. 请说出三种减少页面加载时间的方法。</h2><ul><li><p>优化图片</p></li><li><p>图像格式的选择</p></li><li><p>优化 CSS</p></li><li><p>网站后加斜杠</p></li><li><p>表明高度和宽度</p></li><li><p>减少 http 请求</p></li></ul><h2 id="6-说一下label标签的用法"><a href="#6-说一下label标签的用法" class="headerlink" title="6.说一下label标签的用法"></a>6.说一下label标签的用法</h2><ul><li>label 标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验</li></ul><h2 id="7-事件代理"><a href="#7-事件代理" class="headerlink" title="7.事件代理"></a>7.事件代理</h2><ul><li><p>事件委托是指将事件绑定到目标元素的父元素上，利用冒泡机制触发该事件</p><ol><li>e.target 代表你当前点击的元素</li><li>e.currentTarget 代表你所绑定事件的元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;项目1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;项目2&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let ul=document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">    ul.addEventListener(&#x27;click&#x27;,e=&gt;&#123;</span><br><span class="line">      const target = e.target</span><br><span class="line">      if(target.nodeName===&#x27;LI&#x27;)&#123;</span><br><span class="line">        alert(target.innerHTML)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="8-宏任务和微任务"><a href="#8-宏任务和微任务" class="headerlink" title="8.宏任务和微任务"></a>8.宏任务和微任务</h2><ol><li><p>宏任务：当前调用栈中执行的任务称为宏任务, 如:setTimeout,setInterval,DOM 事件,AJAX 请求</p></li><li><p>微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。如:Promise, async/await, proness.nextTick</p></li><li><p>宏任务中的事件放在 callback queue 中，由事件触发线程维护；微任务的事件放在微任务队列中，由 js 引擎线程维护。</p></li><li><p>执行顺序 ：微任务&gt;DMO 渲染&gt;宏任务</p></li></ol></li></ul><h2 id="9-标签-a-点击虚框问题解决"><a href="#9-标签-a-点击虚框问题解决" class="headerlink" title="9.标签 a 点击虚框问题解决"></a>9.标签 a 点击虚框问题解决</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">a&#123;</span><br><span class="line">outlinr:none</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="10-v8-引擎的垃圾回收机制"><a href="#10-v8-引擎的垃圾回收机制" class="headerlink" title="10.v8 引擎的垃圾回收机制"></a>10.v8 引擎的垃圾回收机制</h2><ul><li>V8 的垃圾回收机制分为新生代和老生代。<ol><li><strong>新生代主要使用 Scavenge 进行管理</strong><ul><li>主要实现是 Cheney 算法,将内存平均分为两块，使用空间叫 From，闲置空间叫 To，新对象都先分配到 From 空间中，在空间快要占满时将存活对象复制到 To 空间中，然后清空 From 的内存空间，此时，调换 From 空间和 To 空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。</li></ul></li><li><strong>老生代主要采用 Mark-Sweep 和 Mark-Compact 算法</strong><ul><li>一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep 在垃圾回收后会产生碎片内存，而 Mark-Compact 在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在 V8 中，老生代是 Mark-Sweep 和 Mark-Compact 两者共同进行管理的。</li></ul></li></ol></li></ul><h2 id="11-事件循环（Event-Loop）"><a href="#11-事件循环（Event-Loop）" class="headerlink" title="11.事件循环（Event Loop）"></a>11.事件循环（Event Loop）</h2><ul><li>主线程运行的时候，会产生堆和栈。栈中的代码会调用各种外部 API。他们在任务队列中加入各种事件。只要调用栈中的代码执行完毕，主线程就会去读取“任务列队”，依次执行哪些事件所对应的回调函数。主线程从“任务队列”中读取事件，这个过程是循环不断的。所以叫事件循环机制。</li></ul><h2 id="12-内存泄露和优化"><a href="#12-内存泄露和优化" class="headerlink" title="12.内存泄露和优化"></a>12.内存泄露和优化</h2><ul><li><p>内存泄漏：存泄露是指程序中<strong>已分配的堆内存</strong>由于某种原因<strong>未释放或者无法释放</strong>，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等后果。</p><ol><li> <strong>缓存</strong></li><li> <strong>作用域未释放（闭包）</strong></li><li> <strong>没有必要的全局变量</strong></li><li> <strong>无效的 DOM 引用</strong></li><li> <strong>定时器未清除</strong></li><li> <strong>事件监听为空白</strong></li></ol></li><li><p>优化</p><ol><li><p><strong>解除引用</strong></p></li><li><p><strong>提供手动清空变量的方法</strong></p></li><li><p><strong>其他方法</strong></p></li></ol></li></ul><ol><li>在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。</li><li>避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。</li><li>避免过多使用闭包。</li><li>注意清除定时器和事件监听器。</li><li>nodejs 中使用 stream 或 buffer 来操作大文件，不会受 nodejs 内存限制。</li><li>使用 redis 等外部工具来缓存数据。</li></ol><h2 id="13-谈谈你对模块化开发的理解？"><a href="#13-谈谈你对模块化开发的理解？" class="headerlink" title="13.谈谈你对模块化开发的理解？"></a>13.谈谈你对模块化开发的理解？</h2><ul><li>所谓的模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数</li></ul><h2 id="14-JS-的各种模块化规范"><a href="#14-JS-的各种模块化规范" class="headerlink" title="14.JS 的各种模块化规范"></a>14.JS 的各种模块化规范</h2><ol><li>AMD：使用 deine 函数</li><li>CMD ：使用 deine 函数</li><li>CommonJs：module 代表当前模块，module.exports 是对外的接口; require 方法用于加载模块</li><li>UMD：无自己的定义规范</li><li>ES6：import 加载模块，export 导出模块</li></ol><ul><li>区别： <img src="E:\桌面\面试题\img\QQ截图20210714131512.png" alt="Image text"></li></ul><h2 id="15-requireJS-的核心原理是什么？"><a href="#15-requireJS-的核心原理是什么？" class="headerlink" title="15.requireJS 的核心原理是什么？"></a>15.requireJS 的核心原理是什么？</h2><ol><li><strong>概念</strong></li></ol><p>requireJS 是基于 AMD 模块加载规范，使用回调函数来解决模块加载的问题。</p><ol start="2"><li><strong>原理</strong> （如何动态加载的？）</li></ol><p>requireJS 是使用创建 script 元素，通过指定 script 元素的 src 属性来实现加载模块的。</p><ol start="3"><li><p><strong>特点</strong></p><ul><li>实现 js 文件的异步加载，避免网页失去响应</li><li>管理模块之间的依赖，便于代码的编写和维护</li></ul></li><li><p><strong>requireJS 为何不会多次加载同一个文件?怎么理解内部机制?</strong></p></li></ol><p>模块的定义是一个<code>function</code>，这个<code>function</code>实际是一个 factory（工厂模式），这个 factory 在需要使用的时候（require(“xxxx”) 的时候）才有可能会被调用。因为如果检查到已经调用过，已经生成了模块实例，就直接返回模块实例，而不再次调用工厂方法了。</p><h2 id="16-ECMAScript-是什么"><a href="#16-ECMAScript-是什么" class="headerlink" title="16.ECMAScript 是什么"></a>16.ECMAScript 是什么</h2><ul><li>ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）通过 ECMA-262 标准化的脚本程序设计语言，一种可以在宿主环境中执行计算并能操作可计算对象的基于对象的程序设计语言。</li></ul><h2 id="17-SEO"><a href="#17-SEO" class="headerlink" title="17.SEO"></a>17.SEO</h2><ul><li> seo是英文Search Engine Optimization的缩写，即一种网站优化技术，也被叫做搜索引擎优化，可以利用搜索引擎的内部检测技术抓取优质内容，优化用户的使用感受，常见于百度、搜狗等搜素引擎。</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
